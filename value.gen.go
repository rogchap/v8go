// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package v8go

import "math/big"

// NewStringValue creates new Value of string
func NewStringValue(iso *Isolate, val string) (*Value, error) {
	return NewValue(iso, val)
}

// NewStringValuer creates new Valuer of string. Same as NewStringValue
// except it is casted to interface.
func NewStringValuer(iso *Isolate, val string) (Valuer, error) {
	return NewValue(iso, val)
}

// NewStringValues creates new list of string.
func NewStringValues(iso *Isolate, vals ...string) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewStringValuers creates new list of string Valuer.
func NewStringValuers(iso *Isolate, vals ...string) ([]Valuer, error) {
	vv, err := NewStringValues(iso, vals...)
	return vv.Valuers(), err
}

// NewIntValue creates new Value of int
func NewIntValue(iso *Isolate, val int) (*Value, error) {
	return NewValue(iso, val)
}

// NewIntValuer creates new Valuer of int. Same as NewIntValue
// except it is casted to interface.
func NewIntValuer(iso *Isolate, val int) (Valuer, error) {
	return NewValue(iso, val)
}

// NewIntValues creates new list of int.
func NewIntValues(iso *Isolate, vals ...int) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewIntValuers creates new list of int Valuer.
func NewIntValuers(iso *Isolate, vals ...int) ([]Valuer, error) {
	vv, err := NewIntValues(iso, vals...)
	return vv.Valuers(), err
}

// NewInt32Value creates new Value of int32
func NewInt32Value(iso *Isolate, val int32) (*Value, error) {
	return NewValue(iso, val)
}

// NewInt32Valuer creates new Valuer of int32. Same as NewInt32Value
// except it is casted to interface.
func NewInt32Valuer(iso *Isolate, val int32) (Valuer, error) {
	return NewValue(iso, val)
}

// NewInt32Values creates new list of int32.
func NewInt32Values(iso *Isolate, vals ...int32) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewInt32Valuers creates new list of int32 Valuer.
func NewInt32Valuers(iso *Isolate, vals ...int32) ([]Valuer, error) {
	vv, err := NewInt32Values(iso, vals...)
	return vv.Valuers(), err
}

// NewInt64Value creates new Value of int64
func NewInt64Value(iso *Isolate, val int64) (*Value, error) {
	return NewValue(iso, val)
}

// NewInt64Valuer creates new Valuer of int64. Same as NewInt64Value
// except it is casted to interface.
func NewInt64Valuer(iso *Isolate, val int64) (Valuer, error) {
	return NewValue(iso, val)
}

// NewInt64Values creates new list of int64.
func NewInt64Values(iso *Isolate, vals ...int64) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewInt64Valuers creates new list of int64 Valuer.
func NewInt64Valuers(iso *Isolate, vals ...int64) ([]Valuer, error) {
	vv, err := NewInt64Values(iso, vals...)
	return vv.Valuers(), err
}

// NewUintValue creates new Value of uint
func NewUintValue(iso *Isolate, val uint) (*Value, error) {
	return NewValue(iso, val)
}

// NewUintValuer creates new Valuer of uint. Same as NewUintValue
// except it is casted to interface.
func NewUintValuer(iso *Isolate, val uint) (Valuer, error) {
	return NewValue(iso, val)
}

// NewUintValues creates new list of uint.
func NewUintValues(iso *Isolate, vals ...uint) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewUintValuers creates new list of uint Valuer.
func NewUintValuers(iso *Isolate, vals ...uint) ([]Valuer, error) {
	vv, err := NewUintValues(iso, vals...)
	return vv.Valuers(), err
}

// NewUint32Value creates new Value of uint32
func NewUint32Value(iso *Isolate, val uint32) (*Value, error) {
	return NewValue(iso, val)
}

// NewUint32Valuer creates new Valuer of uint32. Same as NewUint32Value
// except it is casted to interface.
func NewUint32Valuer(iso *Isolate, val uint32) (Valuer, error) {
	return NewValue(iso, val)
}

// NewUint32Values creates new list of uint32.
func NewUint32Values(iso *Isolate, vals ...uint32) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewUint32Valuers creates new list of uint32 Valuer.
func NewUint32Valuers(iso *Isolate, vals ...uint32) ([]Valuer, error) {
	vv, err := NewUint32Values(iso, vals...)
	return vv.Valuers(), err
}

// NewUint64Value creates new Value of uint64
func NewUint64Value(iso *Isolate, val uint64) (*Value, error) {
	return NewValue(iso, val)
}

// NewUint64Valuer creates new Valuer of uint64. Same as NewUint64Value
// except it is casted to interface.
func NewUint64Valuer(iso *Isolate, val uint64) (Valuer, error) {
	return NewValue(iso, val)
}

// NewUint64Values creates new list of uint64.
func NewUint64Values(iso *Isolate, vals ...uint64) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewUint64Valuers creates new list of uint64 Valuer.
func NewUint64Valuers(iso *Isolate, vals ...uint64) ([]Valuer, error) {
	vv, err := NewUint64Values(iso, vals...)
	return vv.Valuers(), err
}

// NewBigIntValue creates new Value of *big.Int
func NewBigIntValue(iso *Isolate, val *big.Int) (*Value, error) {
	return NewValue(iso, val)
}

// NewBigIntValuer creates new Valuer of bigInt. Same as NewBigIntValue
// except it is casted to interface.
func NewBigIntValuer(iso *Isolate, val *big.Int) (Valuer, error) {
	return NewValue(iso, val)
}

// NewBigIntValues creates new list of bigInt.
func NewBigIntValues(iso *Isolate, vals ...*big.Int) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewBigIntValuers creates new list of *big.Int Valuer.
func NewBigIntValuers(iso *Isolate, vals ...*big.Int) ([]Valuer, error) {
	vv, err := NewBigIntValues(iso, vals...)
	return vv.Valuers(), err
}

// NewBoolValue creates new Value of bool
func NewBoolValue(iso *Isolate, val bool) (*Value, error) {
	return NewValue(iso, val)
}

// NewBoolValuer creates new Valuer of bool. Same as NewBoolValue
// except it is casted to interface.
func NewBoolValuer(iso *Isolate, val bool) (Valuer, error) {
	return NewValue(iso, val)
}

// NewBoolValues creates new list of bool.
func NewBoolValues(iso *Isolate, vals ...bool) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewBoolValuers creates new list of bool Valuer.
func NewBoolValuers(iso *Isolate, vals ...bool) ([]Valuer, error) {
	vv, err := NewBoolValues(iso, vals...)
	return vv.Valuers(), err
}

// NewFloat64Value creates new Value of float64
func NewFloat64Value(iso *Isolate, val float64) (*Value, error) {
	return NewValue(iso, val)
}

// NewFloat64Valuer creates new Valuer of float64. Same as NewFloat64Value
// except it is casted to interface.
func NewFloat64Valuer(iso *Isolate, val float64) (Valuer, error) {
	return NewValue(iso, val)
}

// NewFloat64Values creates new list of float64.
func NewFloat64Values(iso *Isolate, vals ...float64) (Values, error) {
	vv := make(Values, len(vals))
	for _, v := range vals {
		vx, err := NewValue(iso, v)
		if err != nil {
			return nil, err
		}
		vv = append(vv, vx)
	}
	return vv, nil
}

// NewFloat64Valuers creates new list of float64 Valuer.
func NewFloat64Valuers(iso *Isolate, vals ...float64) ([]Valuer, error) {
	vv, err := NewFloat64Values(iso, vals...)
	return vv.Valuers(), err
}
